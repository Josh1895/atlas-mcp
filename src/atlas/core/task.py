"""Core data models for ATLAS tasks and results."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, TYPE_CHECKING
from uuid import uuid4


class TaskStatus(str, Enum):
    """Status of a task in the pipeline."""

    PENDING = "pending"
    CLONING = "cloning"
    GATHERING_CONTEXT = "gathering_context"
    GENERATING = "generating"
    VALIDATING = "validating"
    VOTING = "voting"
    COMPLETED = "completed"
    FAILED = "failed"
    TIMEOUT = "timeout"
    BUDGET_EXCEEDED = "budget_exceeded"


if TYPE_CHECKING:
    from atlas.verification.test_runner import TestResult


@dataclass
class TaskSubmission:
    """Input for a coding task."""

    # Required
    task_id: str = field(default_factory=lambda: str(uuid4()))
    description: str = ""
    repository_url: str = ""

    # Optional - Context
    branch: str = "main"
    base_commit: str | None = None
    relevant_files: list[str] = field(default_factory=list)
    test_command: str | None = None

    # Optional - Configuration
    max_cost_usd: float = 2.0
    timeout_minutes: int = 15

    # Optional - Voting parameters
    voting_k: int = 3
    initial_samples: int = 5
    max_samples: int = 15

    def __post_init__(self):
        if not self.task_id:
            self.task_id = str(uuid4())


@dataclass
class CostBreakdown:
    """Detailed cost breakdown for a task."""

    # Per-model costs
    model_costs: dict[str, float] = field(default_factory=dict)

    # API costs (Context7, etc.)
    api_costs: dict[str, float] = field(default_factory=dict)

    # Per-phase breakdown
    phase_costs: dict[str, float] = field(default_factory=dict)

    @property
    def total(self) -> float:
        """Calculate total cost."""
        return (
            sum(self.model_costs.values())
            + sum(self.api_costs.values())
        )

    def add_model_cost(self, model: str, cost: float) -> None:
        """Add cost for a model."""
        self.model_costs[model] = self.model_costs.get(model, 0.0) + cost

    def add_api_cost(self, api: str, cost: float) -> None:
        """Add cost for an API."""
        self.api_costs[api] = self.api_costs.get(api, 0.0) + cost


@dataclass
class ExecutionTrace:
    """Full execution trace for debugging and auditing."""

    # Timestamps
    started_at: datetime = field(default_factory=datetime.now)
    completed_at: datetime | None = None

    # Phase tracking
    phases: list[dict[str, Any]] = field(default_factory=list)

    # Agent outputs
    agent_outputs: list[dict[str, Any]] = field(default_factory=list)

    # Voting details
    voting_rounds: list[dict[str, Any]] = field(default_factory=list)

    # Errors and warnings
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)

    def add_phase(self, phase: str, details: dict[str, Any] | None = None) -> None:
        """Record a phase transition."""
        self.phases.append({
            "phase": phase,
            "timestamp": datetime.now().isoformat(),
            "details": details or {},
        })

    def add_agent_output(
        self,
        agent_id: str,
        prompt_style: str,
        output: str,
        tokens_used: int,
        cost: float,
    ) -> None:
        """Record an agent's output."""
        self.agent_outputs.append({
            "agent_id": agent_id,
            "prompt_style": prompt_style,
            "output_length": len(output),
            "tokens_used": tokens_used,
            "cost": cost,
            "timestamp": datetime.now().isoformat(),
        })

    def add_voting_round(
        self,
        round_number: int,
        clusters: dict[str, int],
        winner: str | None,
        consensus_reached: bool,
    ) -> None:
        """Record a voting round."""
        self.voting_rounds.append({
            "round": round_number,
            "clusters": clusters,
            "winner": winner,
            "consensus_reached": consensus_reached,
            "timestamp": datetime.now().isoformat(),
        })


@dataclass
class Solution:
    """A solution generated by an agent."""

    # Identification
    agent_id: str
    prompt_style: str

    # Content
    patch: str
    explanation: str = ""

    # Metadata
    model: str = ""
    tokens_used: int = 0
    cost: float = 0.0
    rag_sources: list[str] = field(default_factory=list)

    # Validation results
    is_valid: bool = True
    validation_errors: list[str] = field(default_factory=list)
    test_result: "TestResult | None" = None

    # Clustering
    cluster_id: str | None = None


@dataclass
class TaskResult:
    """Output from a completed task."""

    task_id: str
    status: TaskStatus

    # On success
    patch: str | None = None
    confidence_score: float = 0.0

    # Cost breakdown
    cost_usd: float = 0.0
    cost_breakdown: CostBreakdown = field(default_factory=CostBreakdown)

    # Performance
    duration_seconds: float = 0.0

    # Execution details
    models_used: list[str] = field(default_factory=list)
    votes_cast: int = 0
    samples_generated: int = 0
    consensus_reached: bool = False

    # Debugging
    execution_trace: ExecutionTrace = field(default_factory=ExecutionTrace)
    error_message: str | None = None

    # For reproducibility
    random_seed: int = 0
    config_hash: str = ""

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for MCP response."""
        return {
            "task_id": self.task_id,
            "status": self.status.value,
            "patch": self.patch,
            "confidence_score": self.confidence_score,
            "cost_usd": self.cost_usd,
            "duration_seconds": self.duration_seconds,
            "models_used": self.models_used,
            "votes_cast": self.votes_cast,
            "samples_generated": self.samples_generated,
            "consensus_reached": self.consensus_reached,
            "error_message": self.error_message,
        }
